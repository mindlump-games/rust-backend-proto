use serde::{Deserialize, Serialize};
use std::{
    any::Any,
    borrow::Borrow,
    collections::VecDeque,
    net::{SocketAddr, UdpSocket},
    num::NonZeroUsize,
    str::FromStr,
};

fn main() -> std::io::Result<()> {
    let mut socket = UdpSocket::bind("127.0.0.1:34567")?;
    let peer = SocketAddr::from_str("127.0.0.1:11111").unwrap();
    socket.connect(peer.clone());
    let peer = Some(peer);
    //socket.send(&[0u8; 2]).unwrap();
    let mut chan = UDPChannel {
        socket,
        peer,
        cache: vec![],
    };

    // First let's be the 'frontend' and call the backend.
    //let res = chan
    //    .call_example_message(ExampleMessage {
    //        msg: "hello!".to_string(),
    //    })
    //    .unwrap();
    //// Server responds with world!
    //assert_eq!(res.msg, "world!");

    // Now let's be the server.
    chan.handle_one(&mut Handler).unwrap();

    Ok(())
}

struct Handler;
impl BackendRpcHandler for Handler {
    fn handle_example_message(&mut self, msg: ExampleMessage) -> InternalResult<ExampleReturn> {
        assert_eq!(msg.msg, "hello!");
        return Ok(ExampleReturn {
            msg: "world!".to_string(),
        });
    }
}

struct UDPChannel {
    socket: UdpSocket,
    peer: Option<SocketAddr>,
    cache: Vec<u8>,
}

impl MessageChannel for UDPChannel {
    fn send(&mut self, buf: &[u8]) -> InternalResult<usize> {
        self.socket.send(buf).map_err(|e| Error::IoError(e))
    }

    fn recv(&mut self, buf: &mut [u8]) -> InternalResult<usize> {
        let (amt, dst) = self.socket.recv_from(buf).map_err(|e| Error::IoError(e))?;
        if self.peer.is_none() {
            self.socket.connect(dst).unwrap();
        }
        Ok(amt)
    }

    fn cache(&mut self) -> &mut Vec<u8> {
        &mut self.cache
    }
}

// Autogenerated below.
#[derive(Serialize, Deserialize)]
struct MessageHeader {
    rpc: RpcName,
    body_size: usize,
    is_return: bool,
}
type MessageName = String;
type RpcName = String;

fn find_json_delimiter(buf: &[u8]) -> InternalResult<NonZeroUsize> {
    let mut iter = buf.iter();
    if iter.next() == Some(&('{'.to_ascii_lowercase() as u8)) {
        let mut count = 1;
        let mut indent = 1;
        for b in iter {
            count += 1;
            // TODO/FIXME: Need to support detecting if { or } are inside a
            // string, or some number matches. Basically, need to parse json....
            if &('}'.to_ascii_lowercase() as u8) == b {
                indent -= 1;
                if indent == 0 {
                    // Unsafe ok: We started with 1;
                    return Ok(unsafe { count.try_into().unwrap_unchecked() });
                }
            }
        }
    }
    Err(Error::EndOfFile)
}

fn deserialize_from_slice<'a, T: Deserialize<'a>>(slice: &'a [u8]) -> InternalResult<T> {
    serde_json::from_slice::<T>(slice).or(Err(Error::InvalidParse))
}

trait MessageChannel {
    fn send(&mut self, buf: &[u8]) -> InternalResult<usize>;
    fn recv(&mut self, buf: &mut [u8]) -> InternalResult<usize>;
    // TODO: Handle streamed data
    fn cache(&mut self) -> &mut Vec<u8>;
}

/// For example:
/// message ExampleMessage {
///     msg: string,
/// }
/// message ExampleReturn {
///     msg: string,
/// }
/// service Backend {
///     rpc ExampleMessage(ExampleMessage)
/// }

// Per Message:
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExampleMessage {
    pub msg: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExampleReturn {
    pub msg: String,
}

// Per RPC:
#[derive(Debug)]
pub enum BackendRpcArgVariant {
    ExampleRpc(ExampleMessage),
}
#[derive(Debug)]
pub enum BackendRpcRetVariant {
    ExampleRpc(ExampleReturn),
}
pub const EXAMPLE_RPC_ID: &str = &"ExampleRpc";
/// User to implement handlers
trait BackendRpcHandler {
    fn handle_example_message(&mut self, msg: ExampleMessage) -> InternalResult<ExampleReturn>;
    fn handle_rpc_received(
        &mut self,
        arg: BackendRpcArgVariant,
    ) -> InternalResult<BackendRpcRetVariant> {
        match arg {
            BackendRpcArgVariant::ExampleRpc(m) => Ok(BackendRpcRetVariant::ExampleRpc(
                self.handle_example_message(m)?,
            )),
        }
    }
}

trait BackendServiceClient {
    fn call_example_message(&mut self, arg: ExampleMessage) -> InternalResult<ExampleReturn>;
    fn call(&mut self, arg: &BackendRpcArgVariant) -> InternalResult<BackendRpcRetVariant>;
}

trait BackendService {
    fn handler_loop<H: BackendRpcHandler>(&mut self, handler: &mut H) -> InternalResult<()>;
    fn handle_one<H: BackendRpcHandler>(&mut self, handler: &mut H) -> InternalResult<()>;
}
impl<C: MessageChannel> BackendService for C {
    fn handler_loop<H: BackendRpcHandler>(&mut self, handler: &mut H) -> InternalResult<()> {
        loop {
            self.handle_one(handler)?;
        }
    }

    fn handle_one<H: BackendRpcHandler>(&mut self, handler: &mut H) -> InternalResult<()> {
        let msg = recv_msg(self)?;
        let res = handler.handle_rpc_received(msg)?;

        let ret_buf = BackendSerializer::serialize_rpc_ret(res);
        let send_offset = 0;
        let mut rem = ret_buf.len();
        loop {
            let sent = self.send(&ret_buf[send_offset..])?;
            if sent < rem {
                rem -= sent;
                continue;
            }
            break;
        }
        Ok(())
    }
}

fn recv_msg<C: MessageChannel>(chan: &mut C) -> InternalResult<BackendRpcArgVariant> {
    // If anything in buffer, check if can parse.
    if chan.cache().len() > 0 {
        if let Ok((offset, msg)) = BackendSerializer::parse_rpc_recv(&chan.cache()) {
            // TODO(optimize): Change to vecdeque to improve operation.
            chan.cache().drain(..offset.get());
            return Ok(msg);
        }
    }

    loop {
        // Not parseable from cache, let's read more.
        let mut buf = [0u8; 4096];
        let end = chan.recv(&mut buf).unwrap();

        let mut read_buf = &buf[..end];
        let mut read_from_cache = false;
        if chan.cache().len() > 0 {
            // If there's already data in the cash, parse from there instead of directly from buffer.
            chan.cache().extend_from_slice(&buf[..end]);
            read_buf = chan.cache().as_slice();
            read_from_cache = true;
        }
        match BackendSerializer::parse_rpc_recv(read_buf) {
            Ok((offset, msg)) => {
                if read_from_cache {
                    // TODO(optimize): Change to vecdeque to improve operation.
                    chan.cache().drain(..offset.get());
                }
                // Push remaining data
                if offset.get() < end {
                    chan.cache().extend(&buf[offset.get()..end]);
                }
                return Ok(msg);
            }
            Err(Error::EndOfFile) => {
                // Failed to parse, store new data, continue on
                chan.cache().extend(&buf[..end]);
                continue;
            }
            Err(e) => {
                // Failed to parse, something went wrong and the channel is now broken.
                return Err(e);
            }
        }
    }
}

impl<C: MessageChannel> BackendServiceClient for C {
    fn call_example_message(&mut self, arg: ExampleMessage) -> InternalResult<ExampleReturn> {
        match self.call(&BackendRpcArgVariant::ExampleRpc(arg))? {
            BackendRpcRetVariant::ExampleRpc(res) => Ok(res),
            // Allowed to silence error, because only single RPC may be supported on this service.
            #[allow(unreachable_patterns)]
            res => Err(Error::InvalidResponseId(format!("{:?}", res))),
        }
    }

    // TODO(optimization) Add a queue option to the channel to support queueing
    // messages rather than sending one at a time. In this case, to handle the
    // return value, we would require them to provide a handler in the queue
    // submit() function. (Submit would then be responsible for parsing all
    // return values and calling the correct return handlers.)
    fn call(&mut self, arg: &BackendRpcArgVariant) -> InternalResult<BackendRpcRetVariant> {
        self.send(&BackendSerializer::serialize_rpc_arg(arg))?;

        // Now wait for response. (See optimize todo on function header, no need
        // to wait one.)
        let mut recv_buf = [0u8; 4096];
        let amt = self.recv(&mut recv_buf)?;
        let (_new_start, msg) = BackendSerializer::parse_rpc_result(&recv_buf[..amt])?;
        Ok(msg)
    }
}

// TODO: Change name of error
#[derive(Debug)]
pub enum Error {
    EndOfFile,
    InvalidParse,
    InvalidRpcId,
    InvalidResponseId(String),
    IoError(std::io::Error),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{:?}", self))
    }
}
impl std::error::Error for Error {}

pub type InternalResult<R> = Result<R, Error>;

pub struct BackendSerializer;
impl BackendSerializer {
    /// Wire format:
    /// `[MessageHeader]` | `[ExampleMessage]`
    /// Header            | Body
    pub fn parse_rpc_recv(buf: &[u8]) -> InternalResult<(NonZeroUsize, BackendRpcArgVariant)> {
        // Parse header
        let end = find_json_delimiter(buf)?.get();
        let header = deserialize_from_slice::<MessageHeader>(&buf[..end])?;
        assert!(!header.is_return);

        // Parse Body
        let start = end;
        let end = start + header.body_size;
        if end > buf.len() {
            return Err(Error::EndOfFile);
        }
        let msg = match header.rpc.as_str() {
            EXAMPLE_RPC_ID => BackendRpcArgVariant::ExampleRpc(deserialize_from_slice::<
                ExampleMessage,
            >(&buf[start..end])?),
            _ => return Err(Error::InvalidRpcId),
        };
        // Unsafe ok, arrived at via addition of nonzerousize
        Ok((unsafe { end.try_into().unwrap_unchecked() }, msg))
    }

    pub fn parse_rpc_result(buf: &[u8]) -> InternalResult<(NonZeroUsize, BackendRpcRetVariant)> {
        // Parse header
        let end = find_json_delimiter(buf)?.get();
        let header = deserialize_from_slice::<MessageHeader>(&buf[..end])?;
        assert!(header.is_return);

        // Parse Body
        let start = end;
        let end = start + header.body_size;
        if end > buf.len() {
            return Err(Error::EndOfFile);
        }
        let msg = match header.rpc.as_str() {
            EXAMPLE_RPC_ID => BackendRpcRetVariant::ExampleRpc(deserialize_from_slice::<
                ExampleReturn,
            >(&buf[start..end])?),
            _ => return Err(Error::InvalidRpcId),
        };
        // Unsafe ok, arrived at via addition of nonzerousize
        Ok((unsafe { end.try_into().unwrap_unchecked() }, msg))
    }

    pub fn serialize_rpc_arg(arg: &BackendRpcArgVariant) -> Vec<u8> {
        let mut body;
        let rpc_id;
        match arg {
            BackendRpcArgVariant::ExampleRpc(ref arg) => {
                body = serde_json::to_vec(arg).unwrap();
                rpc_id = EXAMPLE_RPC_ID;
            }
        }
        let header = MessageHeader {
            rpc: rpc_id.to_string(),
            body_size: body.len(),
            is_return: false,
        };
        let mut buf = serde_json::to_vec(&header).unwrap();
        buf.append(&mut body);
        buf
    }

    // TODO(optimization): Should support serializing into a buffer rather than
    // allocating (multiple) vecs.
    pub fn serialize_rpc_ret(ret: BackendRpcRetVariant) -> Vec<u8> {
        let mut body;
        let rpc_id;
        match ret {
            BackendRpcRetVariant::ExampleRpc(r) => {
                rpc_id = String::from(EXAMPLE_RPC_ID);
                body = serde_json::to_vec(&r).unwrap();
            }
        }

        let header = MessageHeader {
            rpc: rpc_id,
            body_size: body.len(),
            is_return: false,
        };
        let mut msg = serde_json::to_vec(&header).unwrap();
        msg.append(&mut body);
        return msg;
    }
}
